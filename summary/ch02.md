## **Ch02. 간단한 프로토콜 HTTP**

### **생각 공유**

**`@ChanhuiSeok`**

### HTTP는 클라이언트와 서버 간에 통신을 한다.
- 클라이언트가 리퀘스트 송신, 서버는 리스폰스를 클라이언트로 송신. 반드시 클라이언트 측으로부터 통신이 시작된다.
    - 리퀘스트 메시지는 메소드(GET, POST, …), URI, 프로토콜 버전, 리퀘스 트 헤더 필드, 엔티티로 구성됨
    - 리스폰스는 서버의 HTTP 버전, 처리 결과를 나타내는 상태코드와 설명, 리스폰스 헤더 필드와 바디로 구성됨
- HTTP는 상태를 유지하지 않는 stateless 프로토콜이다. 리퀘스트-리스폰스 교환 동안 상태를 관리하지 않고, HTTP 프로토콜 레벨에서는 이전에 보냈던 리퀘스트나 이미 되돌려준 리스폰스에 대해 전혀 기억하지 않는다. → **많은 데이터를 매우 빠르고 확실하게 처리하는** **범위성(scalability)을 확보하기 위해** 이처럼 간단하게 설계한 것임
    - 단 웹이 진화하면서 스테이트리스 특성만으로 처리하기 어려운 일이 증가했음. (로그인 상태 유지 등) → 쿠키라는 기술 도입. 쿠키로 인해 HTTP를 이용한 통신에서도 상태를 계속 관리할 수 있게 됨
- HTTP는 URI를 사용해 인터넷 상의 리소스를 지정한다. 덕분에 어떤 장소에 있는 리소스도 호출할 수 있다.
- HTTP 메소드
    - GET : 리퀘스트 URI로 식별된 리소스를 가져올 수 있도록 요구한다.
    - POST : 엔티티 전송
    - PUT : 파일 전송. → (추가) **요청 페이로드를 사용해 새로운 리소스를 생성하거나, 대상 리소스를 나타내는 데이터를 대체합니다(update). POST와 달리 PUT은 멱등성을 가진다. 한 번을 보내도, 여러 번을 연속으로 보내도 같은 효과를 보입니다. 즉, 부수 효과가 없습니다.**
- HTTP 초기 버전은 통신을 한 번 할 때마다 TCP에 의해 연결과 종료를 해야 했다. 리퀘스트를 보낼 때마다 매번 TCP 연결, 종료를 하는 쓸모없는 일이 발생하고, 통신량이 늘어났다.
    - 그래서 HTTP/1.1(과 일부 1.0) 에서는 지속 연결(Persistent Connections)을 고안했다. 어느 한 쪽이 명시적으로 연결을 종료하지 않는 이상, TCP 연결을 계속 유지한다.
    - 지속 연결은 여러 리퀘스트를 보낼 수 있도록 파이프라인화를 가능하게 한다. (여러 리퀘스트 병행해서 보내기 가능하므로 일일이 리스폰스를 기다릴 필요 없음)
- 쿠키 : 리퀘스트와 리스폰스에 쿠키 정보를 추가해, 클라이언트의 상태를 파악하기 위한 시스템.
    - 클라이언트가 쿠키를 가지지 않은 상태에서 리퀘스트 송신
    - **서버는 리스폰스에 쿠키를 붙여서** 송신 (Set-Cookie라는 헤더 필드에 의해 쿠키를 클라이언트에 보존하게 됨)
    - 2회째 이후부턴 클라이언트가 리퀘스트에 쿠키를 붙여서 송신
    - 서버의 리스폰스
    - …

---

**`@jjangsungwon`** 

---

**`@qrlagusdn`** 

- TCP/IP 에 있는 다른 많은 프로토콜과 마찬가지로 HTTP 도 클라이언트와 서버 간에 통신을 함.
- 한 번 통신했을 떄만 본다면 클라이언트와 서버의 역할은 반드시 정해져있음.
- 클라이언트는 Request를 보내고, 서버는 Response를 보냄

```bash
<REQUEST>

GET / HTTP/1.1
Host: developer.mozilla.org
Accept-Language: fr
```

```bash
<RESPONSE>

HTTP/1.1 200 OK
Date: Sat, 09 Oct 2010 14:28:02 GMT
Server: Apache
Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
ETag: "51142bc1-7449-479b075b2891b"
Accept-Ranges: bytes
Content-Length: 29769
Content-Type: text/html

<!DOCTYPE html>… (here come the 29769 bytes of the requested web page)
```

- response에서는 빈 줄로 body를 구분

## HTTP는 Stateless

- HTTP는 상태를 유지하지 않는 프로토콜임
- 즉, 이전 요청이나 응답을 기억하지 못함
- → scalability가 확보됨
- 하지만 파악이 부족하기 때문에 쿠키를 도입해서 해결함

## HTTP Method

GET : 리소스 가져옴

POST : 엔티티 전송

PUT : 파일 전송

DELETE : 파일 삭제

…

## HTTP1.1 의 발전

- 원래는 HTTP Request 하나 마다 TCP 커넥션을 했었음
- 즉, 아래와 같이 request 전에 TCP 3-way handshaking 하고  끝날 때 TCP 4-way handshaking 을 통해 끝냈음
- 서버의 부하가 심함

### 지속 연결

- TCP 연결과 종료에 대한 오버헤드가 줄어듬

![image](https://user-images.githubusercontent.com/37402136/194593892-b3741518-8b31-4f37-9b4f-b5faa086d6ff.png)

### 파이프라인화

- 지속연결을 통해서 여러 리퀘스트를 보낼 수 있도록 파이프라인화가 가능함

![image](https://user-images.githubusercontent.com/37402136/194593914-61d770ee-3ef2-44ff-85a4-d9e67e70bb5a.png)

## TCP 와 HTTP의 차이는??

- 1장에서 배운 것 처럼 HTTP는 TCP/IP 4계층의 Application 단에 위치함
- 즉, 개념적으로는 http 가 tcp/ip 의 위에서 동작하는 것
- tcp
    - byte array 로 정보를 통신
- http
    - string 으로 정보 통신
---

### **회의록**

- **폴더 관리**
  - 프로젝트 루트 경로에 회의록 폴더(`summary`) 라고 만들고, 그 밑에 주마다 논의했던 내용을 작성해서 올린다. (서로 공유한 내용, 회의록 포함)
  - repo에 내용을 올릴 때는 main에 바로 push 한다. (따로 branch, PR 관리 X)

- **issue 탭 사용**
  - 구글밋 전에 한 주동안 스터디했던 장을 개인적으로 간단하게 정리해서 issue 탭에 올린다. (공유하고 싶은 내용이나 자료를 포함해도 괜찮다)
  - issue 탭에 올릴 때 타이틀은 `[Ch1] 챕터 제목 이름` 의 형태로 올린다.
  - 구글밋에서 각자 생각을 공유할 때 issue 탭에 작성한 것을 참고용으로 활용하면 좋겠다.
